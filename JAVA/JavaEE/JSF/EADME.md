## 1.  Что такое JSF?
>JavaServer Faces (JSF) — это фреймворк для веб-приложений, написанный на Java. Он служит для того, чтобы облегчать разработку пользовательских интерфейсов для Java EE-приложений. В отличие от прочих MVC-фреймворков, которые управляются запросами, подход JSF основывается на использовании компонентов. Состояние компонентов пользовательского интерфейса сохраняется, когда пользователь запрашивает новую страницу и затем восстанавливается, если запрос повторяется.
>
>Технология JavaServer Faces включает набор API для представления компонент пользовательского интерфейса (UI) и управления их состоянием, обработкой событий и валидацией вводимой информации, определения навигации, а также поддержку интернационализации (i18n) и доступности (accessibility). В JSF 2.0 в качестве обработчика представления используется технология Facelets которая пришла на замену JSP.

## 2. Что такое Managed Bean?
>В технологии JSF управляемые бины применяются для сохранения состояния web-страниц. Создание бинов и манипулирование ими осуществляются под управлением реализации JSF, которая выполняет следующее:
> 1.  Создание и уничтожение бинов по мере необходимости (этим объясняется происхождение термина «управляемые бины»). Для создания можно использовать аннотацию @ManagedBean.
> 2.  Считывание свойств бина при отображении web-страницы
> 3.  Задание свойств бина при отправке формы

## 3. Каковы три типа тегов для текстовых полей существуют в JSF?
> - <h:inputText> – стандартное текстовое поле для ввода данных.
> - <h:inputSecret> – вводимые данные скрываются (например точками).
> - <h:inputTextarea> — используется для возможности ввода больших объемов текстовой информации.

## 4. Что означает аннотация @ManagedProperty?
>Аннотация @ManagedProperty позволяет внедрять один управляемый бин в другой.
>>@ManagedProperty(value = "#{beanName}")
>>private BeanName beanName;

## 5.  На что указывает аннотация @ApplicationScoped?
>Аннотация *@ApplicationScoped* указывает на то, что управляемый бин будет доступен на протяжении времени жизни приложения

## 6. Что такое связывание ресурсов в JSF?
>Сохранение UI labels, дат, сообщений и другой текстовой информации графических компонентов в различных properties файлах называется связыванием ресурсов. Типичным примером может служить локализация приложения, когда в нескольких файлах resuorcebundle.properties находятся варианты записи лейблов для нескольких языков. Это позволяет не хардкодить информацию на представлениях, а иметь возможность динамического связывания представления и кода в управляемом бине или файле свойств.

## 7. Объясните разницу между required и requiredMessage атрибутов в теге <h:inputText>.
>Эти два тега объявляют необходимость обязательного заполнения текстового поля, а так же сообщения, которое будет выполнено при нарушении этого правила. Такой подход используется при валидации компонентов, например для требования заполнить имя пользователя, пароль или email в соответствующих полях.

## 8.  Какие различные типы навигации по страницам поддерживаются в JSF?
> 1.  Implicit Navigation (неявная навигация),
> 2.  Navigation through Managed Bean (навигация с помощью управляемого бина),
> 3.  Navigation through faces-config.xml (навигация через настройки faces-config.xml),
> 4.  Forward versus Redirect navigation
> 5.  Conditional Navigation (условная навигация)

## 9.  Какие фазы жизненного цикла в JSF вы знаете?
> - **Восстановление представления** — для запрошенной страницы либо извлекается дерево компонентов (если страница уже запрашивалась), либо создается новое дерево компонентов (если страница запрашивается впервые). Для компонентов запрашиваемой страницы восстанавливаются их прошлые состояния (веб-форма заполняет вводимыми значениями).
> - **Применение значений запроса** — всем объектам дерева компонентов присваиваются соответствующие им значения из запроса. Так же, в этой фазе, при необходимости, добавляются события(щелчок по кнопке или ссылке) в очередь событий.
> - **Обработка проверок** — отправленные строковые значения преобразуются в «локальные значения», которые могут представлять собой объекты любого типа. Применяются валидаторы.
> - **Обновление значений модели** — изменяются свойства привязанных к компонентам бинов.
> - **Вызов приложения** — выполняется метод action кнопки или ссылки, щелчок по которой привел к отправке формы.Этот метод может выполнять любую прикладную обработку. Он возвращает строку, которая передается обработчику навигации.
> - **Визуализация ответа** — генерируется html и отправляется клиенту.

## 10. Объясните назначение тега <h:form>.
>Тег <h:form> генерирует элемент формы HTML, который использует «POST» запрос для подтверждения формы и пересылки данных из формы.  Поведение при декодировании: получает Map из свойства «requestParameterMap» из ExternalContext. Если map содержит «clientId» этого UIForm компонента, то вызывается setSubmitted(true) на форме, в противном случае вызывается setSubmitted(false) на форме.
>
>Поведение кодирования: Значение атрибута «метод» должно быть «post». Значение атрибута «action» должно быть результатом передачи идентификатора текущего представления к методу getActionURL() из ViewHandler данного приложения, далее передача String к методу encodeActionURL() из ExternalContext. Необходимо вызвать ViewHandler.writeState() до закрытия элемента «form». Подробнее о деталях поведения формы можно прочитать на сайте Oracle.

## 11.  Какие теги используются для action и navigation?
К тегам для команд action и навигации относятся:
> - <h:commandButton> – генерирует HTML button, которая подтверждает форму и таким образом позволяет начать обработку данных, введенных пользователем.
> - <h:commandLink> – генерирует HTML гиперссылку, эквивалентную тегу анкор в HTML. Может быть связана с управляемым бином или классом Action для обработки событий.

## 12. Какие компоненты используются для отображения данных в табличном виде?
>Основным компонентом для работы с таблицами является <h:dataTable>. Содержит обширные настройки отображения и взаимодействия между представлением и управляемыми бинами.

## 13. Что такое событие (event)?
>Событие — реакция на действие пользователя, например нажатие кнопки, активация ссылки или изменение компонента. JSF поддерживает listeners (слушатели), которые реагируют на различные возникающие события и позволяют обрабатывать их.

## 14. Как мы можем получить generated event?
>Чтобы получить сгенерированное событие мы можем воспользоваться следующей записью:
>>UIComponent ui = new UIComponent();
>>MyFacesEvent ev1 = new MyFacesEvent(ui);
>>UIComponent sc1 = ev1.getComponent();

## 15. Какие различные типы событий существуют в JSF?
>В JSF различают три вида событий:
> - Action Events: событие, которое создается ui component, например command button или command hyperlink.  Обрабатывается в ManagedBean с помощью метода processAction(ActionEvent ae).
> - Value Change Events: событие связанное с изменением значения UI компонента. К компонентам, которые могут генерировать value change events относятся: textfield, radio button, list box и т.д.. Этот тип событий создается сразу же после изменения значения в UI компоненте. Обрабатывается в ManagedBean с помощью метода someMethod(ValueChangeEvent vc).
> - Phase Events: этот тип событий возникает в одной из шести фаз жизненного цикла JFS и выполняется либо в начале, либо в конце каждой фазы. Обрабатывается в ManagedBean с помощью методов: beforePhase(PhaseEvent pe), afterPhase(PhaseEvent pe), PhaseId getPhaseId().

## 16.  Что такое класс-слушатель?
>Класс, который связан с возникающим событием называется класс слушатель (listener class). Создать такой класс можно реализовав интерфейсы PhaseListener, ActionListener или метод с входным параметром (ValueChangeEvent ev).

## 17. Какое назначение тега facelets?
>JSF предоставляет специальный набор тегов, которая дает большую гибкость для управления общими тегами / частями в одном месте для нескольких приложений. Эти теги позволяют создать единый шаблон, который может быть использован в различных приложениях. Включить Facelets теги можно следующим образом:
>
>><html
>>   xmlns="http://www.w3.org/1999/xhtml"
>>   xmlns:ui="http://java.sun.com/jsf/facelets"
>>>

## 18. Назовите несколько facelets тегов.
>Наиболее распространенные facelets теги: <ui:component>, <ui:composition>, <ui:decorate>, <ui:define>, <ui:fragment>, <ui:include>, <ui:insert>, <ui:param>, <ui:remove>, <ui:repeat>.

## 19.  Какие различные типы валидации используются в JSF?
>В JSF есть два типа валидации:
>  - Declarative Validations — валидация, которая срабатывает при помощи стандартных валидаторов JSF или Bean валидаторов.
> - Imperative validation — стандартных сообщений о проверке обычно не достаточно и валидация, которая переопределяет стандартную относится к императивному типу проверок.
>
>Так же есть возможность создать свой собственный класс валидатор с помощью реализации интерфейса Validator и переопределение необходимого метода.

## 20. Какие различные типы выражений поддерживаются JSF EL (Expression Language)?
>Различают три типа выражений в JSF Expression Language:
> - Immediate value expressions — выполняются сразу при отображении страницы. Записываются как ${}.
> - Deferred value expressions — выполняются тогда, когда это необходимо (когда к ним обращаются). Синтаксис: #{expression}. Подразделяются на value expression и method expression.
> - Value expression and method expression. Выражения значения подразделяются на read only и rear-write. Записываются как #{beanName.propertyName}. Method expression позволяют вызывать метод из представления. Синтаксис #{beanName.methodName()}.

## 21. В чем разница между мгновенными и отложенными выражениями?
>Мгновенные выражения выполняются и вычисляются на этапе рендера отображения. Отложенные выражения выполняются при непосредственном вызове. Например выполнение метода при нажатии на кнопку или получения значения свойства при построении фрагмента отображения (например при построении таблицы необходимо получить значения данных).

## 22. Объясните разницу между value expression и method expression.
>Value expression используются для работы со свойствами в управляемом бине. В случае, если для свойства есть только геттер такое выражение относят к read only. Если для свойства есть и геттер и сеттер, то свойство доступно для чтения и записи.
>
>Method expression используется для вызова метода в управляемом бине и получения (если необходимо) его результата для последующей обработки в представлении или другом коде.

## 23. Расскажите о @ViewScoped, @SessionScoped, @CustomScoped и @RequestScoped аннотациях.
> - **@ViewScoped**: означает, что управляемый бин существует на протяжении времени жизни представления JSF (пока страница показывается).
> - **@SessionScoped**: бин будет доступен на протяжении всей HTTP сессии.
> - **@CustomScoped**: бин будет жить столько, сколько он будет находится в Map, которая создается для контроля времени жизни бинов.
> - **@RequestScoped**: бин существует на время жизни запроса-ответа (HTTP request-response).

## 24. Какие существую способы объявить класс управляемым бином JSF?
>Для объявлении класса управляемым бином используется аннотация @ManagedBean(name = «beanName», eager = «true\false»). Другим способом объявить управляемый бин — это указать его в faces-config.xml:

## 25. Как используются атрибуты name и eager в Managed Bean?
>**name**: указывает уникальное имя класса (бина) в JSF. Если имя не указано, то имя совпадает с именем класса где первая буква в нижнем регистре.
>
>**eager**: указывает на время создания бина. Если стоит true, то бин будет создан на старте приложения, если false, то бин будет создан при первом запросе к нему.

## 26. Какие теги для валидации существуют в JSF?
> - **f:validateLength**: проверяет длину строки,
> - **f:validateLongRange**: проверка числового диапазона,
> - **f:validateDoubleRange**: проверка диапазона для типов float, double,
> - **f:validateRegex**: проверка значения согласно регулярному выражению.

## 27. Какие преимущества использования JSF Framework?
> - Отделение бизнес логики от представления.
> - Управление состоянием пользовательского интерфейса UI с помощью нескольких запросов к серверу.
> - Поддерживается реализация собственных компонентов.
> - Легкая передача данных между различными компонентами.
> - JSF является стандартом JEE, что дает уверенность в работе заявленных функций. Существует множество сторонних библиотек для JSF, например библиотека компонентов PrimeFaces.

## 28.  Какие различные теги JSF используются для конвертации?
> - **f:convertNumber*: используется для преобразования строки в число.
> - **f:convertDateTime**: используется для преобразования строки в формат даты.
>>  - **CustomConverter**: созданный пользователем конвертер JSF.

## 29. Перечислите преимущества использования языка выражений (expression language)?
> - Арифметические, логические, реляционные операции могут быть использованы в языке выражений.
> - Автоматическое преобразование типов.
> - Показывает пустые или пропущенные значения как пустые строки вместо NullPointerException.
> - Обеспечивает легкий доступ к предопределенным объектам, таким как запрос (request).

## 30.  Поясните название backing bean.
> Backing Bean — специальный JavaBean (java класс), который собирает значения из компонентов, реагирует на события, взаимодействует с бизнес-логикой. Связан с каждым компонентом. Их может быть несколько и бин не является необязательным для UI компонента, а просто использует его. Backing bean содержит поля, которые будут заполняться из компонента (занесет значения введенные пользователем). JSF компонент не будет работать с Java классами и с чем-то другим, кроме Backing bean.

## 31. Какие стандартные библиотеки тегов JSF вы знаете?
>JSF Core Tags library и JSF HTML tags library. Задать пространство имен в xhtml странице можно следующим образом:
>><html xmlns="http://www.w3.org/1999/xhtml"
>>    xmlns:h="http://java.sun.com/jsf/html"
>>    xmlns:ui="http://java.sun.com/jsf/facelets"
>>    xmlns:c="http://java.sun.com/jsf/core">
>
>Затем с помощью указанных префиксов можно задавать какие-либо компоненты, например <h:form>, <c:validator> и т.д..

## 32. Какие основные функции выполняет метод в backing bean?
> - Проверяет данные компонента
> - Обрабатывает события компонента
> - Выполняет обработку запроса для определения к какой следующей странице необходимо навигироваться.

## 33. Каковы различные реализации JSF API?
> - ADF Faces: реализация JSF стандарта компанией Oracle.
> - Reference Implementation (RI): от Sun Microsystems.
> - Apache MyFaces: open source реализация JavaServer Faces (JSF).
> - Primefaces: мощная библиотека компонентов JSF с поддержкой Ajax и JavaScript.

## 34. Объясните архитектуру JSF.
>JSF основывается на шаблоне проектирования MVC, что означает отделение бизнес логики от представлений. Приложение JSF содержит:
> - UI компоненты, которые представляют состояния объектов на сервере.
> - Классы-помощники на стороне сервера.
> - Validators, event handlers  и navigation handlers.
> - Конфигурацию приложения и используемых ресурсов.
> - Компоненты JavaBeans, которые используются как модель с необходимой функциональностью и информацией.
> - Собственные библиотеки тегов для работы с event handlers и validators.
> - Собственные библиотеки тегов для работы с графическими компонентами.

## 35. Как различные компоненты рендерятся на JSF странице?
>Компоненты JSF отображаются на xhtml странице, включающую библиотеки тегов вроде jsf core, html, facelets tags.

## 36. Может JSF содержать несколько файлов конфигурации?
>Да, может. Их необходимо указать в web.xml.

## 37. Чем различаются понятия backing bean и managed bean?
>Вообще на данный момент существует мнение, что эти понятия не следует различать (например так делает spring). Но если нужно как-то ответить по другому, то:
> - backing bean должны определяться в request scoped. Backing bean связан с формой.
> - Managed bean может определяться в request, session, application scopes. Этот тип бинов регистрируется в контексте приложения JSF и может быть вызван или создан в любое время и месте. Управляемые бины работают с графическими компонентами JSF.

## 38. Как отобразить сообщения об ошибках в JSF?
>Отображать какие либо системные ошибки можно с помощью тега <h:messages>, который может ссылаться на какой-либо графический компонент с помощью атрибута for.

## 39. Объясните назначение тега selectOne menu в JSF.
>Компонент selectOneMenu позволяет выбрать одно из списка значений. Компонент может выглядеть как list box, radio buttons или как меню.

## 40. Объясните в чем разница между атрибутами immediate и rendered?
>Атрибут immediate при значении true позволяет пропускать некоторые фазы жизненного цикла JSF. Например при нажатии на кнопку submit и необходимости подтверждения формы будет пропущена валидация и преобразования. Данные, например, компонента inputTextField не будут отправлены в модель. В общем представление не достучится до своей модели и будет выполнены команды на кнопке с атрибутом immediate=’true’.
>
>Атрибут rendered указывает на необходимость создания (отрисовки) компонента на представлении. Этот атрибут может быть задан с помощью логического выражения.

## 41. Какие два способа связывания поддерживается JSF?
> 1.  Связывание значения компонента с свойством в бине или внешним ресурсом.
> 2.  Связывание экземпляра компонента с свойством в бине.

## 42. Какая минимальная конфигурация необходима для JSF приложения?
>Необходимо настроить как минимум два файла конфигурации:
> - web.xml — основной файл конфигурации веб приложения. Содержит детали развертывания, конфигурации приложения и обработчиков JSF.
> - faces-config.xml — предоставляет настройки приложения, управляемых бинов, навигации, конвертеров, валидаторов.

## 43. Что означает navigation rule в JSF?
>Navigation rule описывает правила навигации в приложении.

## 44. Расскажите о назначение тегов converter в JSF.
>Использование тега конвертера в компоненте позволяет преобразовать данные в необходимый вид. Например, в теге <h:outpuText> можно задать конвертер, который будет обрезать слишком длинную строку.

## 45.  Перечислите преимущества таблицы данных в JSF.
>Использование компонента таблицы в JSF предоставляет широкие возможности для работы с коллекциями или массивами и отображения их содержимого в табличном виде. Поддерживается итерация, предоставляются возможности по преобразованию данных в необходимом виде и многое другое.

## 46. Как реализовать интернационализацию (локализацию) (i18n) в JSF?
>Существуют различные способы реализации локализации в JSF, как стандартными методами, так и с помощью других фреймворков (например Spring). Главное значение локализации в JSF — отсутствие захардкоренных значений компонентов, текстовых данных и др. в коде. Необходимо задать свойство и связать его с помощью resource bundle файлом, в котором будет храниться набор значений для каждого языка (локали).

## 47. Какая модель рендеринга применяется в JSF?
>Архитектура рендеринга JavaServer Faces основана на компонентах. Состояние компонентов пользовательского интерфейса сохраняется, когда пользователь запрашивает новую страницу и затем восстанавливается, если запрос повторяется.

## 48. Что такое render kit?
>Render kit определяет набор компонентов и классов, которые подходят для отображения конкретному пользователю. Например <f:view renderKitId= «PRIMEFACES_MOBILE» /> означает использование мобильного набора компонентов библиотеки Primefaces.

## 49. Что такое view object?
>View object используется специально для представления, но определяется за ее пределами. Он содержит информацию, которую необходимо отобразить в представлении, а так же логику валидации, обработчики событий и определяет взаимодействие с кодом бизнес логики.

## 50. Что подразумевается под Bean Scope?
>Bean scope — механизм связывания бинов и других объектов для возможности доступа к ним из различных компонентов веб приложения.

## 51. В чем разница между JSF-1 и JSF-2?
>JSF 1 нужно забыть:). Не поддерживает Ajax, аннотации, применения шаблонов и вообще достаточно кривой в плане стабильности.

## 52. Может ли отсутствовать faces-config.xml у JSF приложения?
>Можно отказаться от xml файла при использовании аннотаций в коде.

## 53. Сравните JSF и Spring Framework.
>Spring использует Inversion of Control (IoC) и Dependency Injection (DI), а JSF нет.
>Spring состоит из множества различных модулей, таких как Spring Data, Security, MVC и много других отлично взаимодействующих частей. Это помогает создавать большие приложения с меньшими затратами, в то время как JSF, скорее всего, потребует больше кодирования для многих необходимых функций.
>Использование DI в спринг позволяет внедрять POJO классы, в то время как JSF может работать только с JEE архитектурой.

## 54. Почему JSF не так популярна как, например, MVC фреймворки вроде Spring MVC, хотя JSF старше и входит в JEE?
>Достаточно спорный вопрос, но можно перечислить возможные преимущества Spring.
> - Множество реализаций JSF (Mojarra, Primefaces, Richfaces и др) затрудняют выбор, обучение поддержку приложения для разработчиков, в то время как Spring MVC имеет одну и достаточно качественную реализацию.
> - Spring предоставляет множество своих разработок для разносторонних задач, которые сильно облегчают многие инженерные и управленческие задачи проектирования софта.
> - Паттерны DI и IoC позволяют масштабировать и использовать существующий код в различных приложениях.
> - JSF основывается на компонентной архитектуре, в то время как Spring на request-response. Второй подход многими воспринимается легче, используется в многих фрейморках вроде MVC, Struts2 и других.

## 55. Можем ли мы интегрировать JSF с другими популярными фреймворками вроде Spring, Hibernate и т.д.?
>Да, это возможно со всеми популярными фреймворками. Обычно конфигурация приложения для совместной работы JSF, Spring, Hibernate и т.д. не сложная, но из-за объема необходимого кода здесь они приводится не будут. Смотрите документацию для необходимого фреймворка.

## 56. JSF Best Practices.
> Избегать использования JSF компонентов с статичными свойствами.
> Использовать короткие id компонентов.
> Избегать связывания компонентов.
> Использовать facelets для динамического вложения.
