## 1.  Назовите принципы ООП и расскажите о каждом.
>Объе́ктно-ориенти́рованное программи́рование (ООП) — это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.
>Основные принципы ООП: абстракция, инкапсуляция, наследование, полиморфизм.
>
>**Абстракция** —  означает выделение значимой информации и исключение из рассмотрения незначимой. С точки зрения программирования это правильное разделение программы на объекты. Абстракция позволяет отобрать главные характеристики и опустить второстепенные.
>
>Пример: описание должностей в компании. Здесь название должности значимая информация, а описание обязанностей у каждой должности это второстепенная информация. К примеру главной характеристикой для «директор» будет то, что это должность чем-то управляет, а чем именно (директор по персоналу, финансовый директор, исполнительный директор) это уже второстепенная информация.
>
>**Инкапсуляция** — свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации». Пример из жизни — пульт от телевизора. Мы нажимаем кнопочку «увеличить громкость» и она увеличивается, но в этот момент происходят десятки процессов, которые скрыты от нас. Для Java: можно создать класс с 10 методами, например вычисляющие площадь сложной фигуры, но сделать из них 9 private. 10й метод будет называться «вычислитьПлощадь()» и объявлен public, а в нем уже будут вызываться необходимые скрытые от пользователя методы. Именно его и будет вызывать пользователь.
>
>**Наследование** — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
>
>**Полиморфизм** — свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

## 2. Дайте определение понятию “класс”.
>Класс – это описатель общих свойств группы объектов. Этими свойствами могут быть как характеристики объектов (размер, вес, цвет и т.п.), так и поведения, роли и т.п.

## 3. Что такое поле/атрибут класса?
>Поле (атрибут) класса — это характеристика объекта. Например для фигуры это может быть название, площадь, периметр.

## 4. Как правильно организовать доступ к полям класса?
>Модификатор доступа — private. Доступ через методы get\set.

## 5. Дайте определение понятию “конструктор”.
>Конструктор — это специальный метод, который вызывается при создании нового объекта. Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.

## 6. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?
>Конструктор по умолчанию не принимает никаких параметров. Конструктор копирования принимает в качестве параметра объект класса. Конструктор с параметрами принимает на вход параметры (обычно необходимые для инициализации полей класса).
>
>Обращаю внимание, что тема копирования (clone()) достаточно глубокая с возможностью возникновения множества неявных проблем. Немного можно почитать здесь http://habrahabr.ru/post/246993/.

## 7. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
> - private (закрытый) — доступ к члену класса не предоставляется никому, кроме методов этого класса. Другие классы того же пакета также не могут обращаться к private-членам.
> - default, package, friendly, доступ по умолчанию, когда никакой модификатор не присутствует — члена класса считается открытым внутри своего собственного пакета, но не доступен для кода, расположенного вне этого пакета.Т.е. если package2.Class2 extends package1.MainClass, то в Class2 методы без идентификатора из MainClass видны не будут.
> - protected (защищённый) — доступ в пределах пакета и классов наследников. Доступ в классе из другого пакета будет к методам public и protected главного класса. Т.е. если package2.Class2 extends package1.MainClass, то внутри package2.Class2 методы с идентификатором protected из MainClass будут видны.
> - public (открытый) — доступ для всех из любого другого кода проекта
>Модификаторы в списке расположены по возрастающей видимости в программе.

## 8. Расскажите об особенностях класса с единственным закрытым (private) конструктором.
>Невозможно создать объект класса у которого единственный private конструктор за пределами класса. Поэтому нельзя унаследоваться от такого класса. При попытке унаследоваться будет выдаваться ошибка: *There is no default constructor available in имяКласса*. А при попытке создать объект этого класса: *ИмяКласса() has private access in ИмяКласса*

## 9. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?
>super — используется для обращения к базовому классу, а this к текущему.
>Если написать super(), то будет вызван конструктор базового класса, а если this(), то конструктор текущего класса. Это можно использовать, например, при вызове конструктора с параметрами.
>

## 10. Дайте определение понятию “метод”.
>Метод — это последовательность команд, которые вызываются по определенному имени. Можно сказать что это функция и процедура (в случае void метода).

## 11. Что такое сигнатура метода?
>Сигнатура метода в Java — это имя метода плюс параметры (причем порядок параметров имеет значение).
>В сигнатуру метода не входит возвращаемое значение, бросаемые им исключения, а также модификаторы.
>
>Ключевые слова public, protected, private, abstract, static, final, synchronized, native, strictfp в т.ч. аннотации для метода — это модификаторы и не являются частью сигнатуры.

## 12. Какие методы называются перегруженными?
>Java позволяет создавать несколько методов с одинаковыми именами, но разными сигнатурами. Создание метода с тем же именем, но с другим набором параметров называется перегрузкой. Какой из перегруженных методов должен выполняться при вызове, Java определяет на основе фактических параметров.

## 13. Могут ли нестатические методы перегрузить статические?
>Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.

## 14. Расскажите про переопределение методов. Могут ли быть переопределены статические методы?
>Метод в классе-наследнике, совпадающий по сигнатуре с методом из родительского класса называется переопределенным методом. Переопределить базовый статический метод нельзя: *Instance method имяМетода in классНаследник cannot override method имяМетода in родительскийКласс*

## 15. Может ли метод принимать разное количество параметров (аргументы переменной длины)?
>Да. Запись имеет вид method(type … val).

## 16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
>При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass). Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка attempting to use incompatible return type. Но можно сузить возвращаемое значение, если они совместимы.


## 17. Как получить доступ к переопределенным методам родительского класса?
super.method();

## 18. Какие преобразования называются нисходящими и восходящими?
>Преобразование от потомка к предку называется восходящим, от предка к потомку — нисходящим. Нисходящее преобразование должно указываться явно с помощью указания нового типа в скобках.

## 19. Чем отличается переопределение от перегрузки?
>Переопределение используется тогда, когда вы переписываете (переделываете, переопределяете) УЖЕ существующий метод. Перегрузка — это использование одного имени, но с разными входными параметрами. Например нам нужно, чтобы метод toString() для нашего класса выдавал какой-то осмысленный текст. Тогда мы переопределяем метод из класса Object и реализуем этот метод так, как нам это нужно.
>
>Тогда как перегрузка обычно используется, чтобы не придумывать каждый раз новое имя, когда методы отличаются только входными параметрами. При перегрузке необходимый метод определяется на этапе компиляции на основе сигнатуры вызываемого метода, тогда как при переопределении нужный метод будет выявлен во время выполнения исходя из реального типа объекта.

## 20. Где можно инициализировать статические/нестатические поля?
>Статические поля можно инициализировать при объявлении, в статическом или динамическом блоке инициализации. Нестатические поля можно инициализировать при объявлении, в динамическом блоке инициализации или в конструкторе.

## 21. Зачем нужен оператор instanceof?
>Оператор instanceof возвращает true, если объект является экземпляром класса или его потомком.

## 22. Зачем нужны и какие бывают блоки инициализации?
>Блоки инициализации представляют собой наборы выражений инициализации полей, заключенные в фигурные скобки и размещаемые внутри класса вне объявлений методов или конструкторов. Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора. Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса. Блок инициализации способен генерировать исключения, если их объявления перечислены в предложениях throws всех конструкторов класса.
>
>Бывают статические и нестатические блоки инициализации. Так же возможно создать такой блок в анонимном классе.

## 23. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
>Сначала вызываются все статические блоки от первого предка до последнего наследника. Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка).

## 24. Где и для чего используется модификатор abstract?
>Абстрактным называется класс, на основе которого не могут создаваться объекты. При этом наследники класса могут быть не абстрактными, на их основе объекты создавать, соответственно, можно. Для того, чтобы превратить класс в абстрактный перед его именем надо указать модификатор abstract.
>
>Абстрактный метод — метод, который не имеет реализации. Если в классе есть хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

## 25.  Можно ли объявить метод абстрактным и статическим одновременно?
>Нет. Получите: *Illegal combination of modifiers: ‘abstract’ and ‘static’.* Модификатор abstract говорит, что метод будет реализован в другом классе, а static наоборот указывает, что этот метод будет доступен по имени класса.

## 26. Что означает ключевое поле static?
>Модификатор static говорит о том, что метод или поле класса принадлежат не объекту, а классу. Т.е. доступ можно будет получить и не создавая объекта класса. Поля помеченные static инициализируются при инициализации класса. К примеру, Class.forName(«MyClass», true, currentClassLoader), где второй параметр указывает на необходимость проведения инициализации.
>
>На методы, объявленные как static, накладывается ряд ограничений.
> - Они могут вызывать только другие статические методы.
> - Они должны осуществлять доступ только к статическим переменным.
> - Они не могут ссылаться на члены типа this или super.

## 27. К каким конструкциям Java применим модификатор static?
> - К методу.
> - К внутреннему классу.
> - К полю.
> - К импортируемым классам (с 5-ой java). Например, *import static org.junit.Assert.assertThat;*

## 28. Что будет, если в static блоке кода возникнет исключительная ситуация?
>Если в явном виде написать любое исключение в static-блоке, то компилятор не скомпилирует исходники. Это все от того, что компилятор умный. В остальном, взаимодействие с исключениями такое же как и в любом другом месте. Если unchecked исключение вывалится в static-блоке, то класс не будет инициализирован.
>Какое исключение выбрасывается при ошибке в блоке инициализации?
>Для static:
> * java.lang.ExceptionInInitializerError — если исключение наследуется от RuntimeException.
>Для init:
> - exception, который и вызвал исключение, если он наследуется от RuntimeException.
>Верно для static и init:
> - java.lang.Error — если исключение вызвано Error.
> - java.lang.ThreadDeath — смерть потока. Ничего не вываливается.

## 29. Можно ли перегрузить static метод?
>Перегрузить можно, но переопределить нельзя.

## 30. Что такое статический класс, какие особенности его использования?
>Это вложенный класс, который может обращаться только к статическим полям обертывающего его класса, в том числе и приватным. Доступ к нестатическим полям обрамляющего класса может быть осуществлен только через ссылку на экземпляр обрамляющего объекта. К классу высшего уровня модификатор static неприменим.
>
>В примере показано, что для инициализации внутреннего статического класса нет нужды в инициализации родителя. Но в случае обычного внутреннего класса такой номер не пройдет.
>
>Статические вложенные классы, не имеют доступа к нестатическим полям и методам обрамляющего класса, что в некотором роде аналогично статическим методам, объявленным внутри класса. Доступ к нестатическим полям и методам может осуществляться только через ссылку на экземпляр обрамляющего класса. В этом плане static nested классы очень похожи на любые другие классы верхнего уровня.

## 31. Какие особенности инициализации final static переменных?
>Переменные должны быть инициализированы во время объявления или в static блоке.

## 32. Как влияет модификатор static на класс/метод/поле?
>Модификатор static говорит о том, что метод или поле класса принадлежат не объекту, а классу.
>
>Внутри static метода нельзя вызвать не статический метод по имени класса.
>
>Про static класс смотрите ответ выше.

## 33. О чем говорит ключевое слово final?
>Может быть применено к полям, методам или классам. В зависимости к какой сущности приложено данное ключевое слово — будет и различный смысл в его применении.
> - Для класса. Класс помеченный при помощи final не может иметь наследников.
> - Для метода. Метод помеченный при помощи final не может быть переопределен в классах наследниках.
> - Для поля. Поле помеченное при помощи слова final не может изменить свое значение после инициализации (инициализируется либо при описании, либо в конструкторе, статическом или динамическом блоке).
> - Значение локальных переменных, а так же параметров метода помеченных при помощи слова final не могут быть изменены после присвоения.

## 34. Дайте определение понятию “интерфейс”.
>Ключевое слово interface используется для создания полностью абстрактных классов. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не тела методов.
>
>Наличие слова interface означает, что именно так должны выглядеть все классы, которые реализуют данный интерфейс. Таким образом, любой код, использующий конкретный интерфейс, знает только то, какие методы вызываются для этого интерфейса, но не более того.

## 35.  Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
>Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). Все методы и переменные неявно объявляются как public.

## 36. Почему нельзя объявить метод интерфейса с модификатором final или static?
>Вообще с 8й версии можно static, но нужно чтобы было тело метода.
>
>final модификатор просто бессмысленный. Все методы по умолчанию абстрактные, т.е. их невозможно создать не реализовав где-то еще, но это нельзя будет сделать, если у метода идентификатор final.

## 37. Какие типы классов бывают в java 
## 38. Какие особенности создания вложенных классов: простых и статических.
> - Обычные классы (Top level classes)
> - Интерфейсы (Interfaces)
> - Перечисления (Enum)
> - Статические вложенные классы (Static nested classes)
>   - Есть возможность обращения к внутренним статическим полям и методам класса обертки.
>   - Внутренние статические интерфейсы могут содержать только статические методы.
> - Внутренние классы-члены (Member inner classes)
>   - Есть возможность обращения к внутренним полям и методам класса обертки.
>   - Не может иметь статических объявлений.
>   - Нельзя объявить таким образом интерфейс. А если его объявить без идентификатора static, то он автоматически будет добавлен.
>   - Внутри такого класса нельзя объявить перечисления.
>   - Если нужно явно получить this внешнего класса — OuterClass.this
> - Локальный класс (Local inner classes)
>   - Видны только в пределах блока, в котором объявлены.
>   - Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
>   - Не могут иметь внутри себя статических объявлений (полей, методов, классов).
>   - Имеют доступ к полям и методам обрамляющего класса.
>   - Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final.
> - Анонимные классы (Anonymous inner classes)
>   - Локальный класс без имени.

## 39. Что вы знаете о вложенных классах, зачем они используются? Классификация, варианты использования, о нарушении инкапсуляции.
## 40. В чем разница вложенных и внутренних классов?
## 41. Какие классы называются анонимными?
>Вложенный класс — это класс, который объявлен внутри объявления другого класса. Вложенные классы делятся на статические и нестатические (non-static). Собственно нестатические вложенные классы имеют и другое название — внутренние классы (inner classes).
>
>Внутренние классы в Java делятся на такие три вида:
> - внутренние классы-члены (member inner classes);
> - локальные классы (local classes);
> - анонимные классы (anonymous classes).
>Внутренние классы-члены ассоциируются не с самим внешним классом, а с его экземпляром. При этом они имеют доступ ко всем его полям и методам.
>
>Локальные классы (local classes) определяются в блоке Java кода. На практике чаще всего объявление происходит в методе некоторого другого класса. Хотя объявлять локальный класс можно внутри статических и нестатических блоков инициализации.
>
>Анонимный класс (anonymous class) — это локальный класс без имени.
>
>Использование вложенных классов всегда приводит к некоторому нарушению инкапсуляции — вложенный класс может обращаться к закрытым членам внешнего класса (но не наоборот!). Если это обстоятельство учитывается в архитектуре вашего приложения, не стоит уделять ему особого внимания, поскольку внутренний класс всего лишь является специализированным членом внешнего класса.

## 42. Каким образом из вложенного класса получить доступ к полю внешнего класса?
>Если вложенный класс не статический и поле не статическое, то можно просто обратиться к этому полю из внутреннего класса, если только у внутреннего класса не существует поля с таким же литералом, в этом случае нужно обращаться через ссылку на внешний класс так — OuterClass.this.имяПоля
>
>*Из комментария к статье: достаточно, чтобы класс был не статическим, а поле статическое или нет — значения не имеет для Member Inner Class.*

## 43. Каким образом можно обратиться к локальной переменной метода из анонимного класса, объявленного в теле этого метода? Есть ли какие-нибудь ограничения для такой переменной?
>Также как и локальные классы, анонимные могут захватывать переменные, доступ к локальным переменным происходит по тем же правилам:
> - Анонимный класс имеет доступ к полям внешнего класса.
> - Анонимный класс не имеет доступ к локальным переменным области, в которой он определен, если они не финальные (final) или неизменяемые (effectively final).
> - Как и у других внутренних классов, объявление переменной с именем, которое уже занято, затеняет предыдущее объявление.
> - Вы не можете определять статические члены анонимного класса.
>Анонимные классы также могут содержать в себе локальные классы. Конструктора в анонимном классе быть не может.

## 44.  Как связан любой пользовательский класс с классом Object?
>Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object o может ссылаться на объект любого другого класса.

## 45. Расскажите про каждый из методов класса Object.
> - public final native Class getClass() — возвращает в рантайме класс данного объекта.
> - public native int hashCode() — возвращает хеш-код
> - public boolean equals(Object obj) — сравнивает объекты.
> - protected native Object clone() throws CloneNotSupportedException — клонирование объекта
> - public String toString() — возвращает строковое представление объекта.
> - public final native void notify() — просыпается один поток, который ждет на “мониторе” данного объекта.
> - public final native void notifyAll() — просыпаются все потоки, которые ждут на “мониторе” данного объекта.
> - public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.
> - public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
> - public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
> - protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.

## Что такое метод equals(). Чем он отличается от операции ==.
## 47. Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?
## 47. Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?
## 49. В чем особенность работы методов hashCode и equals? Каким образом реализованы методы hashCode и equals в классе Object? Какие правила и соглашения существуют для реализации этих методов? Когда они применяются?
