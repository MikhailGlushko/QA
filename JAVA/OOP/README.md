## 1.  Назовите принципы ООП и расскажите о каждом.
>Объе́ктно-ориенти́рованное программи́рование (ООП) — это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.
>Основные принципы ООП: абстракция, инкапсуляция, наследование, полиморфизм.
>
>**Абстракция** —  означает выделение значимой информации и исключение из рассмотрения незначимой. С точки зрения программирования это правильное разделение программы на объекты. Абстракция позволяет отобрать главные характеристики и опустить второстепенные.
>
>Пример: описание должностей в компании. Здесь название должности значимая информация, а описание обязанностей у каждой должности это второстепенная информация. К примеру главной характеристикой для «директор» будет то, что это должность чем-то управляет, а чем именно (директор по персоналу, финансовый директор, исполнительный директор) это уже второстепенная информация.
>
>**Инкапсуляция** — свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации». Пример из жизни — пульт от телевизора. Мы нажимаем кнопочку «увеличить громкость» и она увеличивается, но в этот момент происходят десятки процессов, которые скрыты от нас. Для Java: можно создать класс с 10 методами, например вычисляющие площадь сложной фигуры, но сделать из них 9 private. 10й метод будет называться «вычислитьПлощадь()» и объявлен public, а в нем уже будут вызываться необходимые скрытые от пользователя методы. Именно его и будет вызывать пользователь.
>
>**Наследование** — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
>
>**Полиморфизм** — свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

## 2. Дайте определение понятию “класс”.
>Класс – это описатель общих свойств группы объектов. Этими свойствами могут быть как характеристики объектов (размер, вес, цвет и т.п.), так и поведения, роли и т.п.

## 3. Что такое поле/атрибут класса?
>Поле (атрибут) класса — это характеристика объекта. Например для фигуры это может быть название, площадь, периметр.

## 4. Как правильно организовать доступ к полям класса?
>Модификатор доступа — private. Доступ через методы get\set.

## 5. Дайте определение понятию “конструктор”.
>Конструктор — это специальный метод, который вызывается при создании нового объекта. Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.

## 6. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?
>Конструктор по умолчанию не принимает никаких параметров. Конструктор копирования принимает в качестве параметра объект класса. Конструктор с параметрами принимает на вход параметры (обычно необходимые для инициализации полей класса).
>
>Обращаю внимание, что тема копирования (clone()) достаточно глубокая с возможностью возникновения множества неявных проблем. Немного можно почитать здесь http://habrahabr.ru/post/246993/.

## 7. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
> - private (закрытый) — доступ к члену класса не предоставляется никому, кроме методов этого класса. Другие классы того же пакета также не могут обращаться к private-членам.
> - default, package, friendly, доступ по умолчанию, когда никакой модификатор не присутствует — члена класса считается открытым внутри своего собственного пакета, но не доступен для кода, расположенного вне этого пакета.Т.е. если package2.Class2 extends package1.MainClass, то в Class2 методы без идентификатора из MainClass видны не будут.
> - protected (защищённый) — доступ в пределах пакета и классов наследников. Доступ в классе из другого пакета будет к методам public и protected главного класса. Т.е. если package2.Class2 extends package1.MainClass, то внутри package2.Class2 методы с идентификатором protected из MainClass будут видны.
> - public (открытый) — доступ для всех из любого другого кода проекта
>Модификаторы в списке расположены по возрастающей видимости в программе.

## 8. Расскажите об особенностях класса с единственным закрытым (private) конструктором.
>Невозможно создать объект класса у которого единственный private конструктор за пределами класса. Поэтому нельзя унаследоваться от такого класса. При попытке унаследоваться будет выдаваться ошибка: *There is no default constructor available in имяКласса*. А при попытке создать объект этого класса: *ИмяКласса() has private access in ИмяКласса*

## 9. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?
>super — используется для обращения к базовому классу, а this к текущему.
>Если написать super(), то будет вызван конструктор базового класса, а если this(), то конструктор текущего класса. Это можно использовать, например, при вызове конструктора с параметрами.
>

## 10. Дайте определение понятию “метод”.
>Метод — это последовательность команд, которые вызываются по определенному имени. Можно сказать что это функция и процедура (в случае void метода).

## 11. Что такое сигнатура метода?
>Сигнатура метода в Java — это имя метода плюс параметры (причем порядок параметров имеет значение).
>В сигнатуру метода не входит возвращаемое значение, бросаемые им исключения, а также модификаторы.
>
>Ключевые слова public, protected, private, abstract, static, final, synchronized, native, strictfp в т.ч. аннотации для метода — это модификаторы и не являются частью сигнатуры.

## 12. Какие методы называются перегруженными?
>Java позволяет создавать несколько методов с одинаковыми именами, но разными сигнатурами. Создание метода с тем же именем, но с другим набором параметров называется перегрузкой. Какой из перегруженных методов должен выполняться при вызове, Java определяет на основе фактических параметров.

## 13. Могут ли нестатические методы перегрузить статические?
>Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.

## 14. Расскажите про переопределение методов. Могут ли быть переопределены статические методы?
>Метод в классе-наследнике, совпадающий по сигнатуре с методом из родительского класса называется переопределенным методом. Переопределить базовый статический метод нельзя: *Instance method имяМетода in классНаследник cannot override method имяМетода in родительскийКласс*

## 15. Может ли метод принимать разное количество параметров (аргументы переменной длины)?
>Да. Запись имеет вид method(type … val).

## 16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
>При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass). Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка attempting to use incompatible return type. Но можно сузить возвращаемое значение, если они совместимы.


## 17. Как получить доступ к переопределенным методам родительского класса?
super.method();

## 18. Какие преобразования называются нисходящими и восходящими?
>Преобразование от потомка к предку называется восходящим, от предка к потомку — нисходящим. Нисходящее преобразование должно указываться явно с помощью указания нового типа в скобках.

## 19. Чем отличается переопределение от перегрузки?
>Переопределение используется тогда, когда вы переписываете (переделываете, переопределяете) УЖЕ существующий метод. Перегрузка — это использование одного имени, но с разными входными параметрами. Например нам нужно, чтобы метод toString() для нашего класса выдавал какой-то осмысленный текст. Тогда мы переопределяем метод из класса Object и реализуем этот метод так, как нам это нужно.
>
>Тогда как перегрузка обычно используется, чтобы не придумывать каждый раз новое имя, когда методы отличаются только входными параметрами. При перегрузке необходимый метод определяется на этапе компиляции на основе сигнатуры вызываемого метода, тогда как при переопределении нужный метод будет выявлен во время выполнения исходя из реального типа объекта.

## 20. Где можно инициализировать статические/нестатические поля?
>Статические поля можно инициализировать при объявлении, в статическом или динамическом блоке инициализации. Нестатические поля можно инициализировать при объявлении, в динамическом блоке инициализации или в конструкторе.
